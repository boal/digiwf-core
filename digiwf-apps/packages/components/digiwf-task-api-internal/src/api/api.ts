/* tslint:disable */
/* eslint-disable */
/**
 * DigiWF Task Management API
 * API for task management.
 *
 * The version of the OpenAPI document: ${project.version}
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import {Configuration} from './configuration';
import globalAxios, {AxiosInstance, AxiosPromise, AxiosRequestConfig} from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  assertParamExists,
  createRequestFunction,
  DUMMY_BASE_URL,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString
} from './common';
// @ts-ignore
import {BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError} from './base';

/**
 * Represents an external link
 * @export
 * @interface ExternalLink
 */
export interface ExternalLink {
    /**
     * Type of link.
     * @type {string}
     * @memberof ExternalLink
     */
    'type': string;
    /**
     * URL of the link.
     * @type {string}
     * @memberof ExternalLink
     */
    'url'?: string;
    /**
     * Label to render.
     * @type {string}
     * @memberof ExternalLink
     */
    'label'?: string;
    /**
     * HTML content of the element.
     * @type {string}
     * @memberof ExternalLink
     */
    'htmlContent'?: string;
    /**
     * Additional extension properties.
     * @type {{ [key: string]: string; }}
     * @memberof ExternalLink
     */
    'additionalParameters'?: { [key: string]: string; };
}
/**
 * Page of tasks.
 * @export
 * @interface PageOfTasks
 */
export interface PageOfTasks {
    /**
     *
     * @type {Array<Task>}
     * @memberof PageOfTasks
     */
    'content': Array<Task>;
    /**
     *
     * @type {PageOfTasksPageable}
     * @memberof PageOfTasks
     */
    'pageable': PageOfTasksPageable;
    /**
     * Get amount of total pages.
     * @type {number}
     * @memberof PageOfTasks
     */
    'totalPages': number;
    /**
     * Get amount of total elements.
     * @type {number}
     * @memberof PageOfTasks
     */
    'totalElements': number;
    /**
     * Get amount of elements in this page.
     * @type {number}
     * @memberof PageOfTasks
     */
    'numberOfElements': number;
    /**
     * Size of the page.
     * @type {number}
     * @memberof PageOfTasks
     */
    'size': number;
    /**
     * Index of the page.
     * @type {number}
     * @memberof PageOfTasks
     */
    'page': number;
    /**
     * Flag indicating if this is a last page.
     * @type {boolean}
     * @memberof PageOfTasks
     */
    'last': boolean;
    /**
     * Flag indicating if this is a first page.
     * @type {boolean}
     * @memberof PageOfTasks
     */
    'first': boolean;
    /**
     * Flag indicating if this page is empty.
     * @type {boolean}
     * @memberof PageOfTasks
     */
    'empty': boolean;
}
/**
 * Pageable object.
 * @export
 * @interface PageOfTasksPageable
 */
export interface PageOfTasksPageable {
    /**
     * The index of the page.
     * @type {number}
     * @memberof PageOfTasksPageable
     */
    'pageNumber': number;
    /**
     * The size of the page.
     * @type {number}
     * @memberof PageOfTasksPageable
     */
    'pageSize': number;
    /**
     * Flag if the content is paged or not.
     * @type {boolean}
     * @memberof PageOfTasksPageable
     */
    'paged': boolean;
    /**
     * Flag if the content is paged or not.
     * @type {boolean}
     * @memberof PageOfTasksPageable
     */
    'unpaged': boolean;
    /**
     *
     * @type {PageOfTasksPageableSort}
     * @memberof PageOfTasksPageable
     */
    'sort': PageOfTasksPageableSort;
}
/**
 * Sort of the page.
 * @export
 * @interface PageOfTasksPageableSort
 */
export interface PageOfTasksPageableSort {
    /**
     * Flag if the sort is empty.
     * @type {boolean}
     * @memberof PageOfTasksPageableSort
     */
    'empty'?: boolean;
    /**
     * Flag if the content is sorted or not.
     * @type {boolean}
     * @memberof PageOfTasksPageableSort
     */
    'unsorted'?: boolean;
    /**
     * Flag if the content is sorted or not.
     * @type {boolean}
     * @memberof PageOfTasksPageableSort
     */
    'sorted'?: boolean;
}
/**
 * Represents a user task.
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * Id of the task.
     * @type {string}
     * @memberof Task
     */
    'id': string;
    /**
     * Name of the task.
     * @type {string}
     * @memberof Task
     */
    'name'?: string;
    /**
     * Tag of the task
     * @type {string}
     * @memberof Task
     */
    'tag'?: string;
    /**
     * Description of the task.
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * Name of the process the task belongs to.
     * @type {string}
     * @memberof Task
     */
    'processName'?: string;
    /**
     * User id of assignee.
     * @type {string}
     * @memberof Task
     */
    'assignee'?: string;
    /**
     * Follow-up date of the task.
     * @type {string}
     * @memberof Task
     */
    'followUpDate'?: string;
    /**
     * Create date and time of the task.
     * @type {string}
     * @memberof Task
     */
    'createTime'?: string;
    /**
     * Reference to schema id.
     * @type {string}
     * @memberof Task
     */
    'schemaRef': string;
    /**
     *
     * @type {TaskSchemaType}
     * @memberof Task
     */
    'schemaType': TaskSchemaType;
    /**
     * List of external links
     * @type {Array<ExternalLink>}
     * @memberof Task
     */
    'externalLinks': Array<ExternalLink>;
}
/**
 * Task assignment information.
 * @export
 * @interface TaskAssignment
 */
export interface TaskAssignment {
    /**
     * User id of the user to assign.
     * @type {string}
     * @memberof TaskAssignment
     */
    'assignee': string;
}
/**
 * Combined schema for a user task.
 * @export
 * @interface TaskCombinedSchema
 */
export interface TaskCombinedSchema {
    /**
     * Id of the schema.
     * @type {string}
     * @memberof TaskCombinedSchema
     */
    'schemaId': string;
    /**
     * JSON combining UI and Data format schema.
     * @type {string}
     * @memberof TaskCombinedSchema
     */
    'schemaJson': string;
}
/**
 * The task deferral information.
 * @export
 * @interface TaskDeferral
 */
export interface TaskDeferral {
    /**
     * Date until the task is deferred.
     * @type {string}
     * @memberof TaskDeferral
     */
    'followUpDate': string;
}
/**
 * Task schema type.
 * @export
 * @enum {string}
 */

export const TaskSchemaType = {
    SchemaBased: 'SCHEMA_BASED',
    VuetifyFormBase: 'VUETIFY_FORM_BASE'
} as const;

export type TaskSchemaType = typeof TaskSchemaType[keyof typeof TaskSchemaType];


/**
 * Represents a user task.
 * @export
 * @interface TaskWithDetails
 */
export interface TaskWithDetails {
    /**
     * Id of the task.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'id': string;
    /**
     * Name of the task.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'name'?: string;
    /**
     * Tag of the task
     * @type {string}
     * @memberof TaskWithDetails
     */
    'tag'?: string;
    /**
     * Description of the task.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'description'?: string;
    /**
     * Name of the process the task belongs to.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'processName'?: string;
    /**
     * Id of the process instance.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'processInstanceId'?: string;
    /**
     * User id of assignee.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'assignee'?: string;
    /**
     * Follow-up date of the task.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'followUpDate'?: string;
    /**
     * Create date and time of the task.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'createTime'?: string;
    /**
     * Reference to schema id.
     * @type {string}
     * @memberof TaskWithDetails
     */
    'schemaRef': string;
    /**
     * Variables of the task.
     * @type {{ [key: string]: object; }}
     * @memberof TaskWithDetails
     */
    'variables': { [key: string]: object; };
    /**
     * Flag indicating if a task can be cancelled.
     * @type {boolean}
     * @memberof TaskWithDetails
     */
    'cancelable': boolean;
    /**
     *
     * @type {TaskSchemaType}
     * @memberof TaskWithDetails
     */
    'schemaType': TaskSchemaType;
    /**
     * List of external links
     * @type {Array<ExternalLink>}
     * @memberof TaskWithDetails
     */
    'externalLinks': Array<ExternalLink>;
}
/**
 * Represents a user task with embedded combined schema.
 * @export
 * @interface TaskWithSchema
 */
export interface TaskWithSchema {
    /**
     * Id of the task.
     * @type {string}
     * @memberof TaskWithSchema
     */
    'id': string;
    /**
     * Name of the task.
     * @type {string}
     * @memberof TaskWithSchema
     */
    'name'?: string;
    /**
     * Tag of the task
     * @type {string}
     * @memberof TaskWithSchema
     */
    'tag'?: string;
    /**
     * Description of the task.
     * @type {string}
     * @memberof TaskWithSchema
     */
    'description'?: string;
    /**
     * Name of the process the task belongs to.
     * @type {string}
     * @memberof TaskWithSchema
     */
    'processName'?: string;
    /**
     * Id of the process instance.
     * @type {string}
     * @memberof TaskWithSchema
     */
    'processInstanceId'?: string;
    /**
     * User id of assignee.
     * @type {string}
     * @memberof TaskWithSchema
     */
    'assignee'?: string;
    /**
     * Follow-up date of the task.
     * @type {string}
     * @memberof TaskWithSchema
     */
    'followUpDate'?: string;
    /**
     * Create date and time of the task.
     * @type {string}
     * @memberof TaskWithSchema
     */
    'createTime'?: string;
    /**
     * Schema of the task.
     * @type {{ [key: string]: object; }}
     * @memberof TaskWithSchema
     */
    'schema': { [key: string]: object; };
    /**
     * Variables of the task.
     * @type {{ [key: string]: object; }}
     * @memberof TaskWithSchema
     */
    'variables': { [key: string]: object; };
    /**
     * Flag indicating if a task can be cancelled.
     * @type {boolean}
     * @memberof TaskWithSchema
     */
    'cancelable': boolean;
    /**
     *
     * @type {TaskSchemaType}
     * @memberof TaskWithSchema
     */
    'schemaType': TaskSchemaType;
    /**
     * List of external links
     * @type {Array<ExternalLink>}
     * @memberof TaskWithSchema
     */
    'externalLinks': Array<ExternalLink>;
}
/**
 * Profile of the user.
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * Unique user id.
     * @type {string}
     * @memberof UserProfile
     */
    'userId': string;
    /**
     * First name.
     * @type {string}
     * @memberof UserProfile
     */
    'firstName': string;
    /**
     * Last name.
     * @type {string}
     * @memberof UserProfile
     */
    'lastName': string;
    /**
     * Primary organizational unit.
     * @type {string}
     * @memberof UserProfile
     */
    'primaryOrgUnit': string;
}
/**
 * Wrapper for variables.
 * @export
 * @interface VariableMap
 */
export interface VariableMap {
    /**
     * Process variables.
     * @type {{ [key: string]: any; }}
     * @memberof VariableMap
     */
    'variables': { [key: string]: any; };
}

/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get file names for task and fieldKey
         * @param {string} taskId Task id.
         * @param {string} filePath File path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames: async (taskId: string, filePath: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getFileNames', 'taskId', taskId)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getFileNames', 'filePath', filePath)
            const localVarPath = `/tasks/id/{taskId}/file`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a presigned url to load, upload or delete a file for a specific field key and file name
         * @param {string} taskId Task id.
         * @param {string} fileName Filename.
         * @param {string} filePath File path
         * @param {'GET' | 'PUT' | 'POST' | 'DELETE'} requestMethod HTTP request method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFile: async (taskId: string, fileName: string, filePath: string, requestMethod: 'GET' | 'PUT' | 'POST' | 'DELETE', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFile', 'taskId', taskId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFile', 'fileName', fileName)
            // verify required parameter 'filePath' is not null or undefined
            assertParamExists('getPresignedUrlForFile', 'filePath', filePath)
            // verify required parameter 'requestMethod' is not null or undefined
            assertParamExists('getPresignedUrlForFile', 'requestMethod', requestMethod)
            const localVarPath = `/tasks/id/{taskId}/file/{fileName}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (filePath !== undefined) {
                localVarQueryParameter['filePath'] = filePath;
            }

            if (requestMethod !== undefined) {
                localVarQueryParameter['requestMethod'] = requestMethod;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * Get file names for task and fieldKey
         * @param {string} taskId Task id.
         * @param {string} filePath File path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames(taskId: string, filePath: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames(taskId, filePath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a presigned url to load, upload or delete a file for a specific field key and file name
         * @param {string} taskId Task id.
         * @param {string} fileName Filename.
         * @param {string} filePath File path
         * @param {'GET' | 'PUT' | 'POST' | 'DELETE'} requestMethod HTTP request method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFile(taskId: string, fileName: string, filePath: string, requestMethod: 'GET' | 'PUT' | 'POST' | 'DELETE', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFile(taskId, fileName, filePath, requestMethod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * Get file names for task and fieldKey
         * @param {string} taskId Task id.
         * @param {string} filePath File path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames(taskId: string, filePath: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames(taskId, filePath, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a presigned url to load, upload or delete a file for a specific field key and file name
         * @param {string} taskId Task id.
         * @param {string} fileName Filename.
         * @param {string} filePath File path
         * @param {'GET' | 'PUT' | 'POST' | 'DELETE'} requestMethod HTTP request method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFile(taskId: string, fileName: string, filePath: string, requestMethod: 'GET' | 'PUT' | 'POST' | 'DELETE', options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFile(taskId, fileName, filePath, requestMethod, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFileNames operation in FileApi.
 * @export
 * @interface FileApiGetFileNamesRequest
 */
export interface FileApiGetFileNamesRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof FileApiGetFileNames
     */
    readonly taskId: string

    /**
     * File path
     * @type {string}
     * @memberof FileApiGetFileNames
     */
    readonly filePath: string
}

/**
 * Request parameters for getPresignedUrlForFile operation in FileApi.
 * @export
 * @interface FileApiGetPresignedUrlForFileRequest
 */
export interface FileApiGetPresignedUrlForFileRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof FileApiGetPresignedUrlForFile
     */
    readonly taskId: string

    /**
     * Filename.
     * @type {string}
     * @memberof FileApiGetPresignedUrlForFile
     */
    readonly fileName: string

    /**
     * File path
     * @type {string}
     * @memberof FileApiGetPresignedUrlForFile
     */
    readonly filePath: string

    /**
     * HTTP request method.
     * @type {'GET' | 'PUT' | 'POST' | 'DELETE'}
     * @memberof FileApiGetPresignedUrlForFile
     */
    readonly requestMethod: 'GET' | 'PUT' | 'POST' | 'DELETE'
}

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * Get file names for task and fieldKey
     * @param {FileApiGetFileNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getFileNames(requestParameters: FileApiGetFileNamesRequest, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).getFileNames(requestParameters.taskId, requestParameters.filePath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a presigned url to load, upload or delete a file for a specific field key and file name
     * @param {FileApiGetPresignedUrlForFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public getPresignedUrlForFile(requestParameters: FileApiGetPresignedUrlForFileRequest, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).getPresignedUrlForFile(requestParameters.taskId, requestParameters.fileName, requestParameters.filePath, requestParameters.requestMethod, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaskApi - axios parameter creator
 * @export
 */
export const TaskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes the assignee of the task.
         * @param {string} taskId Task id.
         * @param {TaskAssignment} taskAssignment Task variables to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTask: async (taskId: string, taskAssignment: TaskAssignment, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('assignTask', 'taskId', taskId)
            // verify required parameter 'taskAssignment' is not null or undefined
            assertParamExists('assignTask', 'taskAssignment', taskAssignment)
            const localVarPath = `/tasks/id/{taskId}/assign`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskAssignment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels the execution of a user task.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTask: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('cancelTask', 'taskId', taskId)
            const localVarPath = `/tasks/id/{taskId}/cancel`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes task specified by id.
         * @param {string} taskId Task id.
         * @param {VariableMap} variableMap Task variables to use during completion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: async (taskId: string, variableMap: VariableMap, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('completeTask', 'taskId', taskId)
            // verify required parameter 'variableMap' is not null or undefined
            assertParamExists('completeTask', 'variableMap', variableMap)
            const localVarPath = `/tasks/id/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableMap, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Defer the task to a follow-up date.
         * @param {string} taskId Task id.
         * @param {TaskDeferral} taskDeferral Task follow-up date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deferTask: async (taskId: string, taskDeferral: TaskDeferral, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('deferTask', 'taskId', taskId)
            // verify required parameter 'taskDeferral' is not null or undefined
            assertParamExists('deferTask', 'taskDeferral', taskDeferral)
            const localVarPath = `/tasks/id/{taskId}/defer`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskDeferral, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a schema for a task by schema id.
         * @summary Returns a schema for a task by schema id.
         * @param {string} schemaId Schema id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (schemaId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSchema', 'schemaId', schemaId)
            const localVarPath = `/schema/id/{schemaId}/combined`
                .replace(`{${"schemaId"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a task by its id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskByTaskId: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTaskByTaskId', 'taskId', taskId)
            const localVarPath = `/tasks/id/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a schema for a task by task id.
         * @summary Returns a schema for a task by task id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskSchema: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTaskSchema', 'taskId', taskId)
            const localVarPath = `/schema/task-id/{taskId}/combined`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a task with schema by its id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskWithSchemaByTaskId: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTaskWithSchemaByTaskId', 'taskId', taskId)
            const localVarPath = `/tasks/id/{taskId}/with-schema`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves the variables for the task specified by id.
         * @param {string} taskId Task id.
         * @param {VariableMap} variableMap Task variables to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTaskVariables: async (taskId: string, variableMap: VariableMap, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('saveTaskVariables', 'taskId', taskId)
            // verify required parameter 'variableMap' is not null or undefined
            assertParamExists('saveTaskVariables', 'variableMap', variableMap)
            const localVarPath = `/tasks/id/{taskId}/save`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableMap, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the assignment of the task.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignTask: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('unassignTask', 'taskId', taskId)
            const localVarPath = `/tasks/id/{taskId}/unassign`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Undefer the task resetting the follow-up date.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeferTask: async (taskId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('undeferTask', 'taskId', taskId)
            const localVarPath = `/tasks/id/{taskId}/undefer`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskApiAxiosParamCreator(configuration)
    return {
        /**
         * Changes the assignee of the task.
         * @param {string} taskId Task id.
         * @param {TaskAssignment} taskAssignment Task variables to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignTask(taskId: string, taskAssignment: TaskAssignment, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignTask(taskId, taskAssignment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels the execution of a user task.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTask(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTask(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Completes task specified by id.
         * @param {string} taskId Task id.
         * @param {VariableMap} variableMap Task variables to use during completion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTask(taskId: string, variableMap: VariableMap, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTask(taskId, variableMap, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Defer the task to a follow-up date.
         * @param {string} taskId Task id.
         * @param {TaskDeferral} taskDeferral Task follow-up date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deferTask(taskId: string, taskDeferral: TaskDeferral, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deferTask(taskId, taskDeferral, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a schema for a task by schema id.
         * @summary Returns a schema for a task by schema id.
         * @param {string} schemaId Schema id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(schemaId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskCombinedSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(schemaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a task by its id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskByTaskId(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskWithDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskByTaskId(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a schema for a task by task id.
         * @summary Returns a schema for a task by task id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskSchema(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskCombinedSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskSchema(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a task with schema by its id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskWithSchemaByTaskId(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskWithSchema>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskWithSchemaByTaskId(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Saves the variables for the task specified by id.
         * @param {string} taskId Task id.
         * @param {VariableMap} variableMap Task variables to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTaskVariables(taskId: string, variableMap: VariableMap, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTaskVariables(taskId, variableMap, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resets the assignment of the task.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignTask(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignTask(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Undefer the task resetting the follow-up date.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async undeferTask(taskId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.undeferTask(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskApiFp(configuration)
    return {
        /**
         * Changes the assignee of the task.
         * @param {string} taskId Task id.
         * @param {TaskAssignment} taskAssignment Task variables to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTask(taskId: string, taskAssignment: TaskAssignment, options?: any): AxiosPromise<void> {
            return localVarFp.assignTask(taskId, taskAssignment, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels the execution of a user task.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTask(taskId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes task specified by id.
         * @param {string} taskId Task id.
         * @param {VariableMap} variableMap Task variables to use during completion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(taskId: string, variableMap: VariableMap, options?: any): AxiosPromise<void> {
            return localVarFp.completeTask(taskId, variableMap, options).then((request) => request(axios, basePath));
        },
        /**
         * Defer the task to a follow-up date.
         * @param {string} taskId Task id.
         * @param {TaskDeferral} taskDeferral Task follow-up date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deferTask(taskId: string, taskDeferral: TaskDeferral, options?: any): AxiosPromise<void> {
            return localVarFp.deferTask(taskId, taskDeferral, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a schema for a task by schema id.
         * @summary Returns a schema for a task by schema id.
         * @param {string} schemaId Schema id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(schemaId: string, options?: any): AxiosPromise<TaskCombinedSchema> {
            return localVarFp.getSchema(schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a task by its id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskByTaskId(taskId: string, options?: any): AxiosPromise<TaskWithDetails> {
            return localVarFp.getTaskByTaskId(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a schema for a task by task id.
         * @summary Returns a schema for a task by task id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskSchema(taskId: string, options?: any): AxiosPromise<TaskCombinedSchema> {
            return localVarFp.getTaskSchema(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a task with schema by its id.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskWithSchemaByTaskId(taskId: string, options?: any): AxiosPromise<TaskWithSchema> {
            return localVarFp.getTaskWithSchemaByTaskId(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves the variables for the task specified by id.
         * @param {string} taskId Task id.
         * @param {VariableMap} variableMap Task variables to save.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTaskVariables(taskId: string, variableMap: VariableMap, options?: any): AxiosPromise<void> {
            return localVarFp.saveTaskVariables(taskId, variableMap, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the assignment of the task.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignTask(taskId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unassignTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Undefer the task resetting the follow-up date.
         * @param {string} taskId Task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undeferTask(taskId: string, options?: any): AxiosPromise<void> {
            return localVarFp.undeferTask(taskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for assignTask operation in TaskApi.
 * @export
 * @interface TaskApiAssignTaskRequest
 */
export interface TaskApiAssignTaskRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiAssignTask
     */
    readonly taskId: string

    /**
     * Task variables to save.
     * @type {TaskAssignment}
     * @memberof TaskApiAssignTask
     */
    readonly taskAssignment: TaskAssignment
}

/**
 * Request parameters for cancelTask operation in TaskApi.
 * @export
 * @interface TaskApiCancelTaskRequest
 */
export interface TaskApiCancelTaskRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiCancelTask
     */
    readonly taskId: string
}

/**
 * Request parameters for completeTask operation in TaskApi.
 * @export
 * @interface TaskApiCompleteTaskRequest
 */
export interface TaskApiCompleteTaskRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiCompleteTask
     */
    readonly taskId: string

    /**
     * Task variables to use during completion.
     * @type {VariableMap}
     * @memberof TaskApiCompleteTask
     */
    readonly variableMap: VariableMap
}

/**
 * Request parameters for deferTask operation in TaskApi.
 * @export
 * @interface TaskApiDeferTaskRequest
 */
export interface TaskApiDeferTaskRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiDeferTask
     */
    readonly taskId: string

    /**
     * Task follow-up date.
     * @type {TaskDeferral}
     * @memberof TaskApiDeferTask
     */
    readonly taskDeferral: TaskDeferral
}

/**
 * Request parameters for getSchema operation in TaskApi.
 * @export
 * @interface TaskApiGetSchemaRequest
 */
export interface TaskApiGetSchemaRequest {
    /**
     * Schema id.
     * @type {string}
     * @memberof TaskApiGetSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getTaskByTaskId operation in TaskApi.
 * @export
 * @interface TaskApiGetTaskByTaskIdRequest
 */
export interface TaskApiGetTaskByTaskIdRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiGetTaskByTaskId
     */
    readonly taskId: string
}

/**
 * Request parameters for getTaskSchema operation in TaskApi.
 * @export
 * @interface TaskApiGetTaskSchemaRequest
 */
export interface TaskApiGetTaskSchemaRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiGetTaskSchema
     */
    readonly taskId: string
}

/**
 * Request parameters for getTaskWithSchemaByTaskId operation in TaskApi.
 * @export
 * @interface TaskApiGetTaskWithSchemaByTaskIdRequest
 */
export interface TaskApiGetTaskWithSchemaByTaskIdRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiGetTaskWithSchemaByTaskId
     */
    readonly taskId: string
}

/**
 * Request parameters for saveTaskVariables operation in TaskApi.
 * @export
 * @interface TaskApiSaveTaskVariablesRequest
 */
export interface TaskApiSaveTaskVariablesRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiSaveTaskVariables
     */
    readonly taskId: string

    /**
     * Task variables to save.
     * @type {VariableMap}
     * @memberof TaskApiSaveTaskVariables
     */
    readonly variableMap: VariableMap
}

/**
 * Request parameters for unassignTask operation in TaskApi.
 * @export
 * @interface TaskApiUnassignTaskRequest
 */
export interface TaskApiUnassignTaskRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiUnassignTask
     */
    readonly taskId: string
}

/**
 * Request parameters for undeferTask operation in TaskApi.
 * @export
 * @interface TaskApiUndeferTaskRequest
 */
export interface TaskApiUndeferTaskRequest {
    /**
     * Task id.
     * @type {string}
     * @memberof TaskApiUndeferTask
     */
    readonly taskId: string
}

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * Changes the assignee of the task.
     * @param {TaskApiAssignTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public assignTask(requestParameters: TaskApiAssignTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).assignTask(requestParameters.taskId, requestParameters.taskAssignment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels the execution of a user task.
     * @param {TaskApiCancelTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public cancelTask(requestParameters: TaskApiCancelTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).cancelTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes task specified by id.
     * @param {TaskApiCompleteTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public completeTask(requestParameters: TaskApiCompleteTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).completeTask(requestParameters.taskId, requestParameters.variableMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Defer the task to a follow-up date.
     * @param {TaskApiDeferTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deferTask(requestParameters: TaskApiDeferTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).deferTask(requestParameters.taskId, requestParameters.taskDeferral, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a schema for a task by schema id.
     * @summary Returns a schema for a task by schema id.
     * @param {TaskApiGetSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getSchema(requestParameters: TaskApiGetSchemaRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getSchema(requestParameters.schemaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a task by its id.
     * @param {TaskApiGetTaskByTaskIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTaskByTaskId(requestParameters: TaskApiGetTaskByTaskIdRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTaskByTaskId(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a schema for a task by task id.
     * @summary Returns a schema for a task by task id.
     * @param {TaskApiGetTaskSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTaskSchema(requestParameters: TaskApiGetTaskSchemaRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTaskSchema(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a task with schema by its id.
     * @param {TaskApiGetTaskWithSchemaByTaskIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTaskWithSchemaByTaskId(requestParameters: TaskApiGetTaskWithSchemaByTaskIdRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).getTaskWithSchemaByTaskId(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves the variables for the task specified by id.
     * @param {TaskApiSaveTaskVariablesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public saveTaskVariables(requestParameters: TaskApiSaveTaskVariablesRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).saveTaskVariables(requestParameters.taskId, requestParameters.variableMap, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the assignment of the task.
     * @param {TaskApiUnassignTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public unassignTask(requestParameters: TaskApiUnassignTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).unassignTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Undefer the task resetting the follow-up date.
     * @param {TaskApiUndeferTaskRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public undeferTask(requestParameters: TaskApiUndeferTaskRequest, options?: AxiosRequestConfig) {
        return TaskApiFp(this.configuration).undeferTask(requestParameters.taskId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of tasks for the groups the current user is in (candidate groups) including already assigned.
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {string} [userId] A user id string used during search with the user string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedGroupTasks: async (page?: number, size?: number, query?: string, tag?: string, sort?: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/group/assigned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of tasks assigned to current user.
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [followUp] An optional flag to include tasks with follow-up date set to a day before today.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserTasks: async (page?: number, size?: number, query?: string, tag?: string, followUp?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (followUp !== undefined) {
                localVarQueryParameter['followUp'] = (followUp as any instanceof Date) ?
                    (followUp as any).toISOString().substr(0,10) :
                    followUp;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of unassigned tasks for the groups the current user is in (candidate groups).
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnassignedGroupTasks: async (page?: number, size?: number, query?: string, tag?: string, sort?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks/group/unassigned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of tasks for the groups the current user is in (candidate groups) including already assigned.
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {string} [userId] A user id string used during search with the user string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedGroupTasks(page?: number, size?: number, query?: string, tag?: string, sort?: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOfTasks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedGroupTasks(page, size, query, tag, sort, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of tasks assigned to current user.
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [followUp] An optional flag to include tasks with follow-up date set to a day before today.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserTasks(page?: number, size?: number, query?: string, tag?: string, followUp?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOfTasks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserTasks(page, size, query, tag, followUp, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of unassigned tasks for the groups the current user is in (candidate groups).
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnassignedGroupTasks(page?: number, size?: number, query?: string, tag?: string, sort?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOfTasks>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnassignedGroupTasks(page, size, query, tag, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Returns a list of tasks for the groups the current user is in (candidate groups) including already assigned.
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {string} [userId] A user id string used during search with the user string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedGroupTasks(page?: number, size?: number, query?: string, tag?: string, sort?: string, userId?: string, options?: any): AxiosPromise<PageOfTasks> {
            return localVarFp.getAssignedGroupTasks(page, size, query, tag, sort, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of tasks assigned to current user.
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [followUp] An optional flag to include tasks with follow-up date set to a day before today.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserTasks(page?: number, size?: number, query?: string, tag?: string, followUp?: string, sort?: string, options?: any): AxiosPromise<PageOfTasks> {
            return localVarFp.getCurrentUserTasks(page, size, query, tag, followUp, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of unassigned tasks for the groups the current user is in (candidate groups).
         * @param {number} [page] Current page used index for paging operations started from zero.
         * @param {number} [size] Current page size used for paging operations started from 1.
         * @param {string} [query] A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [tag] A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
         * @param {string} [sort] A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnassignedGroupTasks(page?: number, size?: number, query?: string, tag?: string, sort?: string, options?: any): AxiosPromise<PageOfTasks> {
            return localVarFp.getUnassignedGroupTasks(page, size, query, tag, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAssignedGroupTasks operation in TasksApi.
 * @export
 * @interface TasksApiGetAssignedGroupTasksRequest
 */
export interface TasksApiGetAssignedGroupTasksRequest {
    /**
     * Current page used index for paging operations started from zero.
     * @type {number}
     * @memberof TasksApiGetAssignedGroupTasks
     */
    readonly page?: number

    /**
     * Current page size used for paging operations started from 1.
     * @type {number}
     * @memberof TasksApiGetAssignedGroupTasks
     */
    readonly size?: number

    /**
     * A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
     * @type {string}
     * @memberof TasksApiGetAssignedGroupTasks
     */
    readonly query?: string

    /**
     * A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
     * @type {string}
     * @memberof TasksApiGetAssignedGroupTasks
     */
    readonly tag?: string

    /**
     * A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
     * @type {string}
     * @memberof TasksApiGetAssignedGroupTasks
     */
    readonly sort?: string

    /**
     * A user id string used during search with the user string.
     * @type {string}
     * @memberof TasksApiGetAssignedGroupTasks
     */
    readonly userId?: string
}

/**
 * Request parameters for getCurrentUserTasks operation in TasksApi.
 * @export
 * @interface TasksApiGetCurrentUserTasksRequest
 */
export interface TasksApiGetCurrentUserTasksRequest {
    /**
     * Current page used index for paging operations started from zero.
     * @type {number}
     * @memberof TasksApiGetCurrentUserTasks
     */
    readonly page?: number

    /**
     * Current page size used for paging operations started from 1.
     * @type {number}
     * @memberof TasksApiGetCurrentUserTasks
     */
    readonly size?: number

    /**
     * A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
     * @type {string}
     * @memberof TasksApiGetCurrentUserTasks
     */
    readonly query?: string

    /**
     * A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
     * @type {string}
     * @memberof TasksApiGetCurrentUserTasks
     */
    readonly tag?: string

    /**
     * An optional flag to include tasks with follow-up date set to a day before today.
     * @type {string}
     * @memberof TasksApiGetCurrentUserTasks
     */
    readonly followUp?: string

    /**
     * A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
     * @type {string}
     * @memberof TasksApiGetCurrentUserTasks
     */
    readonly sort?: string
}

/**
 * Request parameters for getUnassignedGroupTasks operation in TasksApi.
 * @export
 * @interface TasksApiGetUnassignedGroupTasksRequest
 */
export interface TasksApiGetUnassignedGroupTasksRequest {
    /**
     * Current page used index for paging operations started from zero.
     * @type {number}
     * @memberof TasksApiGetUnassignedGroupTasks
     */
    readonly page?: number

    /**
     * Current page size used for paging operations started from 1.
     * @type {number}
     * @memberof TasksApiGetUnassignedGroupTasks
     */
    readonly size?: number

    /**
     * A query string used during search, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
     * @type {string}
     * @memberof TasksApiGetUnassignedGroupTasks
     */
    readonly query?: string

    /**
     * A tag string used during search with the tag string, format is &lt;field&gt;&lt;op&gt;&lt;value&gt;.
     * @type {string}
     * @memberof TasksApiGetUnassignedGroupTasks
     */
    readonly tag?: string

    /**
     * A sort parameter, &lt;direction&gt;&lt;field&gt; (direction is represented by + for asc or - for desc), asc is default.
     * @type {string}
     * @memberof TasksApiGetUnassignedGroupTasks
     */
    readonly sort?: string
}

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Returns a list of tasks for the groups the current user is in (candidate groups) including already assigned.
     * @param {TasksApiGetAssignedGroupTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getAssignedGroupTasks(requestParameters: TasksApiGetAssignedGroupTasksRequest = {}, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getAssignedGroupTasks(requestParameters.page, requestParameters.size, requestParameters.query, requestParameters.tag, requestParameters.sort, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of tasks assigned to current user.
     * @param {TasksApiGetCurrentUserTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getCurrentUserTasks(requestParameters: TasksApiGetCurrentUserTasksRequest = {}, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getCurrentUserTasks(requestParameters.page, requestParameters.size, requestParameters.query, requestParameters.tag, requestParameters.followUp, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of unassigned tasks for the groups the current user is in (candidate groups).
     * @param {TasksApiGetUnassignedGroupTasksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getUnassignedGroupTasks(requestParameters: TasksApiGetUnassignedGroupTasksRequest = {}, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).getUnassignedGroupTasks(requestParameters.page, requestParameters.size, requestParameters.query, requestParameters.tag, requestParameters.sort, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resolves a user by id.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('resolveUser', 'userId', userId)
            const localVarPath = `/user/id/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Resolves a user by id.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Resolves a user by id.
         * @param {string} userId User id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveUser(userId: string, options?: any): AxiosPromise<UserProfile> {
            return localVarFp.resolveUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for resolveUser operation in UserApi.
 * @export
 * @interface UserApiResolveUserRequest
 */
export interface UserApiResolveUserRequest {
    /**
     * User id.
     * @type {string}
     * @memberof UserApiResolveUser
     */
    readonly userId: string
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Resolves a user by id.
     * @param {UserApiResolveUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resolveUser(requestParameters: UserApiResolveUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).resolveUser(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}


